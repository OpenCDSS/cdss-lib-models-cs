using System;
using System.Collections.Generic;
using System.IO;

// StateMod_Plan - class to store plan information

/* NoticeStart

CDSS Models Java Library
CDSS Models Java Library is a part of Colorado's Decision Support Systems (CDSS)
Copyright (C) 1994-2019 Colorado Department of Natural Resources

CDSS Models Java Library is free software:  you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CDSS Models Java Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CDSS Models Java Library.  If not, see <https://www.gnu.org/licenses/>.

NoticeEnd */

namespace DWR.StateMod
{

	using GeoRecord = RTi.GIS.GeoView.GeoRecord;
	using HasGeoRecord = RTi.GIS.GeoView.HasGeoRecord;
	using IOUtil = RTi.Util.IO.IOUtil;
	using Message = RTi.Util.Message.Message;
	using StringUtil = RTi.Util.String.StringUtil;

	/// <summary>
	/// Object used to store plan information.  All set routines set
	/// the COMP_PLANS flag dirty.  A new object will have empty non-null
	/// lists, null time series, and defaults for all other data.
	/// </summary>
	public class StateMod_Plan : StateMod_Data, ICloneable, IComparable<StateMod_Data>, HasGeoRecord
	{

	// ID, name, river node (cgoto), and switch are in the base class.

	/// <summary>
	/// Plan type.
	/// </summary>
	protected internal int _iPlnTyp;

	/// <summary>
	/// Plan efficiency flag.
	/// </summary>
	protected internal int _PeffFlag;

	/// <summary>
	/// Plan efficiency.
	/// </summary>
	protected internal double[] _Peff = new double[12]; // only used if _PeffFlag = 1, but set aside memory

	/// <summary>
	/// Return flow table.
	/// </summary>
	protected internal int _iPrf;

	/// <summary>
	/// Plan failure switch.
	/// </summary>
	protected internal int _iPfail;

	/// <summary>
	/// Initial plan storage value (AF).
	/// </summary>
	protected internal double _Psto1;

	/// <summary>
	/// Source ID of structure where reuse water became available or a T&C condition
	/// originated (for type 8).
	/// </summary>
	protected internal string _Psource;

	/// <summary>
	/// Source account of structure where reuse water became available or a T&C condition
	/// originated (for type 8).  Treat as a string but is an integer in StateMod so right-justify output.
	/// </summary>
	protected internal string _iPAcc;

	/// <summary>
	/// Reference to spatial data for this plan -- currently NOT cloned.
	/// </summary>
	protected internal GeoRecord _georecord;

	/// <summary>
	/// Comments provided by user - # comments before each plan.  An empty (non-null) list is guaranteed.
	/// TODO SAM 2010-12-14 Evaluate whether this can be in StateMod_Data or will it bloat memory.
	/// </summary>
	protected internal IList<string> __commentsBeforeData = new List<string>();

	/// <summary>
	/// Construct a new plan and assign data to reasonable defaults.
	/// </summary>
	public StateMod_Plan() : base()
	{
		initialize(true);
	}

	/// <summary>
	/// Construct a new plan. </summary>
	/// <param name="initialize_defaults"> If true, assign data to reasonable defaults.
	/// If false, all data are set to missing. </param>
	public StateMod_Plan(bool initialize_defaults) : base()
	{
		initialize(initialize_defaults);
	}

	/// <summary>
	/// Copy constructor. </summary>
	/// <param name="deep_copy"> If true, make a deep copy including secondary vectors of data.
	/// Currently only false is recognized, in which primitive data are copied.  This is
	/// suitable to allow the StateMod_Plan_JFrame class to know when changes have
	/// been made to data on the main screen. </param>
	public StateMod_Plan(StateMod_Plan plan, bool deep_copy) : this()
	{
		// Base class...
		// TODO
		// Local data members...
		_iPlnTyp = plan._iPlnTyp;
		_PeffFlag = plan._PeffFlag;
		_iPrf = plan._iPrf;
		_iPfail = plan._iPfail;
		_Psto1 = plan._Psto1;
		_Psource = plan._Psource;
		_georecord = plan._georecord;
	}

	/// <summary>
	/// Accepts any changes made inside of a GUI to this object.
	/// </summary>
	public virtual void acceptChanges()
	{
		_isClone = false;
		_original = null;
	}

	/// <summary>
	/// Compares this object with its original value (generated by createBackup() upon
	/// entering a GUI) to see if it has changed.
	/// </summary>
	public virtual bool changed()
	{
		if (_original == null)
		{
			return true;
		}
		if (compareTo(_original) == 0)
		{
			return false;
		}
		return true;
	}

	/// <summary>
	/// Clones the data object. </summary>
	/// <returns> a cloned object. </returns>
	public override object clone()
	{
		StateMod_Plan plan = (StateMod_Plan)base.clone();
		plan._isClone = true;
		return plan;
	}

	/// <summary>
	/// Compares this object to another StateMod_Plan object. </summary>
	/// <param name="data"> the object to compare against. </param>
	/// <returns> 0 if they are the same, 1 if this object is greater than the other
	/// object, or -1 if it is less. </returns>
	public virtual int CompareTo(StateMod_Data data)
	{
		int res = base.CompareTo(data);
		if (res != 0)
		{
			return res;
		}

		// TODO SAM 2007-03-01 Need to enable
		//StateMod_Plan p = (StateMod_Plan)o;

	/* TODO SAM 2006-08-22 need to review
		if (_divcap < d._divcap) {
			return -1;
		}
		else if (_divcap > d._divcap) {
			return 1;
		}
		
		res = _username.compareTo(d._username);
		if (res != 0) {
			return res;
		}
	
		if (_idvcom < d._idvcom) {
			return -1;
		}
		else if (_idvcom > d._idvcom) {
			return 1;
		}
	
		if (_divefc < d._divefc) {
			return -1;
		}
		else if (_divefc > d._divefc) {
			return 1;
		}
	
		if (_area < d._area) {
			return -1;
		}
		else if (_area > d._area) {
			return 1;
		}
	
		if (_irturn < d._irturn) {
			return -1;
		}
		else if (_irturn > d._irturn) {
			return 1;
		}
		
		if (_demsrc < d._demsrc) {
			return -1;
		}
		else if (_demsrc > d._demsrc) {
			return 1;
		}
	
		if (_ireptype < d._ireptype) {
			return -1;
		}
		else if (_ireptype > d._ireptype) {
			return 1;
		}
	
		if (_awc < d._awc) {
			return -1;
		}
		else if (_awc > d._awc) {
			return 1;
		}
	
		if (_diveff == null && d._diveff == null) {
			return 0;
		}
		else if (_diveff == null && d._diveff != null) {
			return -1;
		}
		else if (_diveff != null && d._diveff == null) {
			return 1;
		}
		else {
			int size1 = _diveff.length;
			int size2 = d._diveff.length;
			if (size1 < size2) {
				return -1;
			}
			else if (size1 > size2) {
				return 1;
			}
			
			for (int i = 0; i < size1; i++) {
				if (_diveff[i] < d._diveff[i]) {
					return -1;
				}
				else if (_diveff[i] > d._diveff[i]) {
					return 1;
				}
			}
		}
	*/

		return 0;
	}

	/// <summary>
	/// Creates a copy of the object for later use in checking to see if it was changed in a GUI.
	/// </summary>
	public virtual void createBackup()
	{
		_original = (StateMod_Plan)clone();
		((StateMod_Plan)_original)._isClone = false;
		_isClone = true;
	}

	/// <summary>
	/// Clean up for garbage collection.
	/// </summary>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: protected void finalize() throws Throwable
	~StateMod_Plan()
	{
		_Psource = null;
		_georecord = null;
//JAVA TO C# CONVERTER NOTE: The base class finalizer method is automatically called in C#:
//		base.finalize();
	}

	/// <summary>
	/// Return the comments from the input file that immediate precede the data. </summary>
	/// <returns> the comments from the input file that immediate precede the data. </returns>
	public virtual IList<string> getCommentsBeforeData()
	{
		return __commentsBeforeData;
	}

	/// <summary>
	/// Get the geographical data associated with the plan. </summary>
	/// <returns> the GeoRecord for the plan. </returns>
	public virtual GeoRecord getGeoRecord()
	{
		return _georecord;
	}

	/// <summary>
	/// Return the account of the source structure.
	/// </summary>
	public virtual string getIPAcc()
	{
		return _iPAcc;
	}

	/// <summary>
	/// Return the plan fail flag.
	/// </summary>
	public virtual int getIPfail()
	{
		return _iPfail;
	}

	/// <summary>
	/// Return a list of failure flag option strings, for use in GUIs.
	/// The options are of the form "0" if include_notes is false and
	/// "0 - Do not turn plan off if it fails", if include_notes is true. </summary>
	/// <returns> a list of plan type switch option strings, for use in GUIs. </returns>
	/// <param name="include_notes"> Indicate whether notes should be added after the parameter values. </param>
	public static IList<string> getIPfailChoices(bool include_notes)
	{
		IList<string> v = new List<string>(2);
		v.Add("0 - Do not turn plan off if it fails");
		v.Add("1 - Turn plan off if it fails");
		if (!include_notes)
		{
			// Remove the trailing notes...
			int size = v.Count;
			for (int i = 0; i < size; i++)
			{
				v[i] = StringUtil.getToken(v[i], " ", 0, 0);
			}
		}
		return v;
	}

	/// <summary>
	/// Return the default failure switch choice.  This can be used by GUI code
	/// to pick a default for a new plan. </summary>
	/// <returns> the default plan type choice. </returns>
	public static string getIPfailDefault(bool include_notes)
	{ // Make this agree with the above method...
		if (include_notes)
		{
			return "0 - Do not turn plan off if it fails";
		}
		else
		{
			return "0";
		}
	}

	/// <summary>
	/// Return the plan type.
	/// </summary>
	public virtual int getIPlnTyp()
	{
		return _iPlnTyp;
	}

	/// <summary>
	/// Return a list of plan type option strings, for use in GUIs.
	/// The options are of the form "1" if include_notes is false and
	/// "1 - Terms and Conditions (T&C)", if include_notes is true. </summary>
	/// <returns> a list of plan type switch option strings, for use in GUIs. </returns>
	/// <param name="include_notes"> Indicate whether notes should be added after the parameter values. </param>
	public static IList<string> getIPlnTypChoices(bool include_notes)
	{
		IList<string> v = new List<string>(9);
		v.Add("1 - Terms and Conditions (T&C)");
		v.Add("2 - Well Augmentation");
		v.Add("3 - Reuse to a Reservoir");
		v.Add("4 - Reuse to a Diversion");
		v.Add("5 - Reuse to a Reservoir from Transmountain");
		v.Add("6 - Reuse to a Diversion from Transmountain");
		v.Add("7 - Transmountain import");
		v.Add("8 - Recharge Plan");
		v.Add("9 - Out-of-Priority Diversion or Storage");
		v.Add("10 - Special Well Augmentation");
		v.Add("11 - Accounting Plan");
		v.Add("12 - Release Limit Plan");
		if (!include_notes)
		{
			// Remove the trailing notes...
			int size = v.Count;
			for (int i = 0; i < size; i++)
			{
				v[i] = StringUtil.getToken(v[i], " ", 0, 0);
			}
		}
		return v;
	}

	/// <summary>
	/// Return the default plan type choice.  This can be used by GUI code
	/// to pick a default for a new plan. </summary>
	/// <returns> the default plan type choice. </returns>
	public static string getIPlnTypDefault(bool include_notes)
	{ // Make this agree with the above method...
		if (include_notes)
		{
			return ("1 - Terms and Conditions (T&C)");
		}
		else
		{
			return "1";
		}
	}

	/// <summary>
	/// Return the plan efficiency for a specific month. </summary>
	/// <param name="imon"> the efficiency month (0+, where 0 is the first month according to the data set control file) </param>
	public virtual double getPeff(int imon)
	{
		return _Peff[imon];
	}

	/// <summary>
	/// Return the plan efficiency flag.
	/// </summary>
	public virtual int getPeffFlag()
	{
		return _PeffFlag;
	}

	/// <summary>
	/// Return a list of efficiency flag option strings, for use in GUIs.
	/// The options are of the form "0" if include_notes is false and
	/// "0 - Off", if include_notes is true. </summary>
	/// <returns> a list of on/off switch option strings, for use in GUIs. </returns>
	/// <param name="includeNotes"> Indicate whether notes should be added after the parameter values. </param>
	public static IList<string> getPeffFlagChoices(bool includeNotes)
	{
		IList<string> v = new List<string>(2);
		v.Add("0 - Not used");
		v.Add("1 - Specify 12 plan efficiency values");
		v.Add("999 - Use source structure's efficiency values");
		if (!includeNotes)
		{
			// Remove the trailing notes...
			int size = v.Count;
			for (int i = 0; i < size; i++)
			{
				v[i] = StringUtil.getToken(v[i], " ", 0, 0);
			}
		}
		return v;
	}

	/// <summary>
	/// Return the plan efficiency flag choice.  This can be used by GUI code to pick a default for a new plan. </summary>
	/// <returns> the default plan efficiency choice. </returns>
	public static string getPeffFlagDefault(bool includeNotes)
	{ // Make this agree with the above method...
		if (includeNotes)
		{
			return ("999 - use source structure's efficiency values");
		}
		else
		{
			return "999";
		}
	}

	/// <summary>
	/// Return a list of on/off switch option strings, for use in GUIs.
	/// The options are of the form "0" if include_notes is false and
	/// "0 - Off", if include_notes is true. </summary>
	/// <returns> a list of on/off switch option strings, for use in GUIs. </returns>
	/// <param name="include_notes"> Indicate whether notes should be added after the parameter values. </param>
	public static IList<string> getPonChoices(bool include_notes)
	{
		IList<string> v = new List<string>(2);
		v.Add("0 - Off"); // Possible options are listed here.
		v.Add("1 - On");
		if (!include_notes)
		{
			// Remove the trailing notes...
			int size = v.Count;
			for (int i = 0; i < size; i++)
			{
				v[i] = StringUtil.getToken(v[i], " ", 0, 0);
			}
		}
		return v;
	}

	/// <summary>
	/// Return the default on/off switch choice.  This can be used by GUI code
	/// to pick a default for a new plan. </summary>
	/// <returns> the default reservoir replacement choice. </returns>
	public static string getPonDefault(bool include_notes)
	{ // Make this agree with the above method...
		if (include_notes)
		{
			return ("1 - On");
		}
		else
		{
			return "1";
		}
	}

	/// <summary>
	/// Return the return flow table.
	/// </summary>
	public virtual int getIPrf()
	{
		return _iPrf;
	}

	/// <summary>
	/// Return a list of return flow type option strings, for use in GUIs.
	/// The options are of the form "0" if includeNotes is false and
	/// "0 - not used", if include_notes is true. </summary>
	/// <returns> a list of plan type switch option strings, for use in GUIs. </returns>
	/// <param name="includeNotes"> Indicate whether notes should be added after the parameter values. </param>
	public static IList<string> getIPrfChoices(bool includeNotes)
	{
		IList<string> v = new List<string>(2);
		v.Add("0 - no return flows calculated");
		v.Add("1 - T&C plan with return data in plan return file");
		v.Add("8 - Recharge plan with return data in plan return file");
		v.Add("999 - use source structure's return flow data");
		if (!includeNotes)
		{
			// Remove the trailing notes...
			int size = v.Count;
			for (int i = 0; i < size; i++)
			{
				v[i] = StringUtil.getToken(v[i], " ", 0, 0);
			}
		}
		return v;
	}

	/// <summary>
	/// Return the default return flow type choice.  This can be used by GUI code
	/// to pick a default for a new plan. </summary>
	/// <returns> the default plan type choice. </returns>
	public static string getIPrfDefault(bool includeNotes)
	{ // Make this agree with the above method...
		if (includeNotes)
		{
			return "999 - use source structure's return flow data";
		}
		else
		{
			return "999";
		}
	}

	/// <summary>
	/// Return the ID of the source structure.
	/// </summary>
	public virtual string getPsource()
	{
		return _Psource;
	}

	/// <summary>
	/// Return the plan initial storage.
	/// </summary>
	public virtual double getPsto1()
	{
		return _Psto1;
	}

	/// <summary>
	/// Initialize data.
	/// Sets the smdata_type to _dataset.COMP_PLANS. </summary>
	/// <param name="initialize_defaults"> If true, assign data to reasonable defaults.
	/// If false, all data are set to missing. </param>
	private void initialize(bool initialize_defaults)
	{
		_smdata_type = StateMod_DataSet.COMP_PLANS;
		if (initialize_defaults)
		{
			_iPlnTyp = 1;
			_PeffFlag = 999;
			_iPrf = 999;
			_iPfail = 0;
			_Psto1 = 0.0;
			_Psource = "";
			_iPAcc = "";
		}
		else
		{
			// Use missing data...
			_iPlnTyp = StateMod_Util.MISSING_INT;
			_PeffFlag = StateMod_Util.MISSING_INT;
			_iPrf = StateMod_Util.MISSING_INT;
			_iPfail = StateMod_Util.MISSING_INT;
			_Psto1 = StateMod_Util.MISSING_DOUBLE;
			_Psource = StateMod_Util.MISSING_STRING;
			_iPAcc = StateMod_Util.MISSING_STRING;
		}
		_georecord = null;
	}

	/// <summary>
	/// Indicate whether a file is a StateMod plan file.  Currently the only
	/// check that is done is to see if the file name ends in "pln". </summary>
	/// <param name="filename"> File name. </param>
	/// <returns> true if the file appears to be a plan file, false if not. </returns>
	public static bool isStateModPlanFile(string filename)
	{
		if (StringUtil.endsWithIgnoreCase(filename,".pln"))
		{
			return true;
		}
		return false;
	}

	/// <summary>
	/// Read plan information in and store in a list. </summary>
	/// <param name="filename"> filename containing plan information </param>
	/// <exception cref="Exception"> if an error occurs </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public static java.util.List<StateMod_Plan> readStateModFile(String filename) throws Exception
	public static IList<StateMod_Plan> readStateModFile(string filename)
	{
		string routine = "StateMod_Plan.readStateModFile";
		string iline = null;
		IList<string> v = new List<string>(9);
		IList<StateMod_Plan> thePlans = new List<StateMod_Plan>();
		int linecount = 0;

		StateMod_Plan aPlan = null;
		StreamReader @in = null;

		Message.printStatus(2, routine, "Reading plan file: " + filename);
		int size = 0;
		int errorCount = 0;
		try
		{
			@in = new StreamReader(IOUtil.getPathUsingWorkingDir(filename));
			IList<string> commentsBeforeData = new List<string>();
			while (!string.ReferenceEquals((iline = @in.ReadLine()), null))
			{
				++linecount;
				// check for comments
				if (iline.StartsWith("#>", StringComparison.Ordinal) || (iline.Trim().Length == 0))
				{
					// Special dynamic header comments written by software and blank lines - no need to keep
					continue;
				}
				else if (iline.StartsWith("#", StringComparison.Ordinal))
				{
					// Comment prior to a plan - do not trim so that input/output comparisons can be made but
					// do remove the initial comment character
					commentsBeforeData.Add(iline.Substring(1));
					continue;
				}

				if (Message.isDebugOn)
				{
					Message.printDebug(50, routine, "line: " + iline);
				}
				// Break the line using whitespace, while allowing for quoted strings...
				v = StringUtil.breakStringList(iline, " \t", StringUtil.DELIM_ALLOW_STRINGS | StringUtil.DELIM_SKIP_BLANKS);
				size = 0;
				if (v != null)
				{
					size = v.Count;
				}
				if (size < 11)
				{
					Message.printStatus(2, routine, "Ignoring line " + linecount + " not enough data values.  Have " + size + " expecting " + 11);
					++errorCount;
					continue;
				}
				// Uncomment if testing...
				//Message.printStatus ( 2, routine, "" + v );

				// Allocate new plan node and set the values
				aPlan = new StateMod_Plan();
				aPlan.setID(v[0].Trim());
				aPlan.setName(v[1].Trim());
				aPlan.setCgoto(v[2].Trim());
				aPlan.setSwitch(v[3].Trim());
				aPlan.setIPlnTyp(v[4].Trim());
				aPlan.setPeffFlag(v[5].Trim());
				int peffFlag = aPlan.getPeffFlag();
				aPlan.setIPrf(v[6].Trim());
				aPlan.setIPfail(v[7].Trim());
				aPlan.setPsto1(v[8].Trim());
				aPlan.setPsource(v[9].Trim());
				aPlan.setIPAcc(v[10].Trim());

				// Read the efficiencies...

				if (peffFlag == 1)
				{
					iline = @in.ReadLine();
					++linecount;
					if (string.ReferenceEquals(iline, null))
					{
						throw new IOException("Unexpected end of file after line " + linecount + " - expecting 12 efficiency values.");
					}
					v = StringUtil.breakStringList(iline, " \t", StringUtil.DELIM_ALLOW_STRINGS | StringUtil.DELIM_SKIP_BLANKS);
					size = 0;
					if (v != null)
					{
						size = v.Count;
					}
					if (size != 12)
					{
						Message.printStatus(2, routine, "Ignoring line " + linecount + " not enough data values.  Have " + size + " expecting " + 12);
						++errorCount;
					}
					else
					{
						for (int iEff = 0; iEff < 12; iEff++)
						{
							string val = v[0].Trim();
							try
							{
								aPlan.setPeff(iEff,double.Parse(val));
							}
							catch (Exception)
							{
								Message.printStatus(2, routine, "Efficiencies on line " + linecount + " value \"" + val + "\" is not a number.");
									++errorCount;
							}
						}
					}
				}

				// Set the comments

				if (commentsBeforeData.Count > 0)
				{
					// Set comments that have been read previous to this line.  First, attempt to discard
					// comments that do not below with the operational right.  For now, search backward for
					// "EndHeader" and "--e" which indicate the end of the header.  If found, discard the comments prior
					// to this because they are assumed to be file header comments, not comments for a specific right.
					// Only do this for the first right because the user may actually want to include the header
					// information in their file periodically to help with formatting
					string comment;
					if (thePlans.Count == 0)
					{
						for (int iComment = commentsBeforeData.Count - 1; iComment >= 0; --iComment)
						{
							comment = commentsBeforeData[iComment].ToUpper();
							if ((comment.IndexOf("ENDHEADER", StringComparison.Ordinal) >= 0) || (comment.IndexOf("--E", StringComparison.Ordinal) >= 0))
							{
								// Remove the comments above the position.
								while (iComment >= 0)
								{
									commentsBeforeData.RemoveAt(iComment--);
								}
								break;
							}
						}
					}
					aPlan.setCommentsBeforeData(commentsBeforeData);
				}
				// Always clear out for next right...
				commentsBeforeData = new List<string>(1);

				// Set the plan to not dirty because it was just initialized...

				aPlan.setDirty(false);

				// Add the plan to the vector of plans
				thePlans.Add(aPlan);
			}
		}
		catch (Exception e)
		{
			Message.printWarning(3, routine, "Error reading line " + linecount + " \"" + iline + "\" uniquetempvar.");
			Message.printWarning(3, routine, e);
			throw e;
		}
		finally
		{
			if (@in != null)
			{
				@in.Close();
			}
		}
		if (errorCount > 0)
		{
			throw new Exception("There were " + errorCount + " errors processing the data - refer to log file.");
		}
		return thePlans;
	}

	/// <summary>
	/// Cancels any changes made to this object within a GUI since createBackup()
	/// was called and sets _original to null.
	/// </summary>
	public override void restoreOriginal()
	{
		StateMod_Plan plan = (StateMod_Plan)_original;
		base.restoreOriginal();

		_iPlnTyp = plan._iPlnTyp;
		_PeffFlag = plan._PeffFlag;
		_iPrf = plan._iPrf;
		_iPfail = plan._iPfail;
		_Psto1 = plan._Psto1;
		_Psource = plan._Psource;
		_isClone = false;
		_original = null;
	}

	/// <summary>
	/// Set the comments before the data in the input file. </summary>
	/// <param name="commentsBeforeData"> comments before the data in the input file. </param>
	public virtual void setCommentsBeforeData(IList<string> commentsBeforeData)
	{
		bool dirty = false;
		int size = commentsBeforeData.Count;
		IList<string> commentsBeforeData0 = getCommentsBeforeData();
		if (size != commentsBeforeData0.Count)
		{
			dirty = true;
		}
		else
		{
			// Lists are the same size and there may not have been any changes
			// Need to check each string in the comments
			for (int i = 0; i < size; i++)
			{
				if (!commentsBeforeData[i].Equals(commentsBeforeData0[i]))
				{
					dirty = true;
					break;
				}
			}
		}
		if (dirty)
		{
			// Something was different so set the comments and change the dirty flag
			__commentsBeforeData = commentsBeforeData;
			setDirty(true);
			if (!_isClone && _dataset != null)
			{
				_dataset.setDirty(StateMod_DataSet.COMP_PLANS,true);
			}
		}
	}

	/// <summary>
	/// Set the plan failure flag. </summary>
	/// <param name="iPfail"> Plan failure flag. </param>
	public virtual void setIPfail(int iPfail)
	{
		if (iPfail != _iPfail)
		{
			_iPfail = iPfail;
			setDirty(true);
			if (!_isClone && _dataset != null)
			{
				_dataset.setDirty(StateMod_DataSet.COMP_PLANS, true);
			}
		}
	}

	/// <summary>
	/// Set the plan failure flag. </summary>
	/// <param name="iPfail"> plan failure flag. </param>
	public virtual void setIPfail(int? iPfail)
	{
		setIPfail(iPfail.Value);
	}

	/// <summary>
	/// Set the plan failure flag. </summary>
	/// <param name="iPfail"> plan failure flag. </param>
	public virtual void setIPfail(string iPfail)
	{
		if (string.ReferenceEquals(iPfail, null))
		{
			return;
		}
		setIPfail(StringUtil.atoi(iPfail.Trim()));
	}

	/// <summary>
	/// Set the plan return flow table. </summary>
	/// <param name="iPrf"> Plan return flow table. </param>
	public virtual void setIPrf(int iPrf)
	{
		if (iPrf != _iPrf)
		{
			_iPrf = iPrf;
			setDirty(true);
			if (!_isClone && _dataset != null)
			{
				_dataset.setDirty(StateMod_DataSet.COMP_PLANS, true);
			}
		}
	}

	/// <summary>
	/// Set the plan return flow table. </summary>
	/// <param name="iPrf"> plan return flow table. </param>
	public virtual void setIPrf(int? iPrf)
	{
		setIPrf(iPrf.Value);
	}

	/// <summary>
	/// Set the plan return flow table. </summary>
	/// <param name="iPrf"> plan return flow table. </param>
	public virtual void setIPrf(string iPrf)
	{
		if (string.ReferenceEquals(iPrf, null))
		{
			return;
		}
		setIPrf(StringUtil.atoi(iPrf.Trim()));
	}

	/// <summary>
	/// Set the geographic information object associated with the plan. </summary>
	/// <param name="georecord"> Geographic record associated with the plan. </param>
	public virtual void setGeoRecord(GeoRecord georecord)
	{
		_georecord = georecord;
	}

	/// <summary>
	/// Set the source account. </summary>
	/// <param name="iPAcc"> source account. </param>
	public virtual void setIPAcc(string iPAcc)
	{
		if (string.ReferenceEquals(iPAcc, null))
		{
			return;
		}
		if (!iPAcc.Equals(_iPAcc))
		{
			_iPAcc = iPAcc;
			setDirty(true);
			if (!_isClone && _dataset != null)
			{
				_dataset.setDirty(StateMod_DataSet.COMP_PLANS, true);
			}
		}
	}

	/// <summary>
	/// Set the plan type. </summary>
	/// <param name="iPlnTyp"> Plan type. </param>
	public virtual void setIPlnTyp(int iPlnTyp)
	{
		if (iPlnTyp != _iPlnTyp)
		{
			_iPlnTyp = iPlnTyp;
			setDirty(true);
			if (!_isClone && _dataset != null)
			{
				_dataset.setDirty(StateMod_DataSet.COMP_PLANS, true);
			}
		}
	}

	/// <summary>
	/// Set the plan type. </summary>
	/// <param name="iPlnTyp"> plan type. </param>
	public virtual void setIPlnTyp(int? iPlnTyp)
	{
		setIPlnTyp(iPlnTyp.Value);
	}

	/// <summary>
	/// Set the plan type. </summary>
	/// <param name="iPlnTyp"> plan type. </param>
	public virtual void setIPlnTyp(string iPlnTyp)
	{
		if (string.ReferenceEquals(iPlnTyp, null))
		{
			return;
		}
		setIPlnTyp(StringUtil.atoi(iPlnTyp.Trim()));
	}

	/// <summary>
	/// Set the plan efficiency for a particular month.
	/// The efficiencies are stored in the order of the year for the data set.  For
	/// example, if water years are used, the first efficiency will be for October.  For
	/// calendar year, the first efficiency will be for January. </summary>
	/// <param name="index"> month index (0+) </param>
	/// <param name="peff"> monthly efficiency </param>
	public virtual void setPeff(int index, double peff)
	{
		if (_Peff[index] != peff)
		{
			_Peff[index] = peff;
			setDirty(true);
			if (!_isClone && _dataset != null)
			{
				_dataset.setDirty(StateMod_DataSet.COMP_PLANS, true);
			}
		}
	}

	/// <summary>
	/// Set the plan efficiency flag. </summary>
	/// <param name="peff"> plan efficiency flag. </param>
	public virtual void setPeffFlag(int PeffFlag)
	{
		if (_PeffFlag != PeffFlag)
		{
			_PeffFlag = PeffFlag;
			setDirty(true);
			// TODO SAM 2006-08-22 Take out after initial troubleshooting is complete
			//Message.printStatus ( 2, "", "Setting object dirty = true" );
			//String s = "not null";
			//if ( _dataset == null ) {
			//	s = "null";
			//}
			//Message.printStatus ( 2, "", "_isClone=" + _isClone + " _dataset="+s );
			if (!_isClone && _dataset != null)
			{
				_dataset.setDirty(StateMod_DataSet.COMP_PLANS, true);
				//Message.printStatus ( 2, "", "Is data set dirt?"  + _dataset.isDirty() );
			}
		}
	}

	/// <summary>
	/// Set the plan efficiency flag. </summary>
	/// <param name="PeffFlag"> plan efficiency flag. </param>
	public virtual void setPeffFlag(int? PeffFlag)
	{
		setPeffFlag(PeffFlag.Value);
	}

	/// <summary>
	/// Set the plan efficiency. </summary>
	/// <param name="PeffFlag"> Plan efficiency. </param>
	public virtual void setPeffFlag(string PeffFlag)
	{
		if (string.ReferenceEquals(PeffFlag, null))
		{
			return;
		}
		setPeffFlag(StringUtil.atoi(PeffFlag.Trim()));
	}

	/// <summary>
	/// Set the source id. </summary>
	/// <param name="Psource"> source id. </param>
	public virtual void setPsource(string Psource)
	{
		if (string.ReferenceEquals(Psource, null))
		{
			return;
		}
		if (!Psource.Equals(_Psource))
		{
			_Psource = Psource;
			setDirty(true);
			if (!_isClone && _dataset != null)
			{
				_dataset.setDirty(StateMod_DataSet.COMP_PLANS, true);
			}
		}
	}

	/// <summary>
	/// Set the plan initial storage. </summary>
	/// <param name="peff"> plan initial storage. </param>
	public virtual void setPsto1(double Psto1)
	{
		if (_Psto1 != Psto1)
		{
			_Psto1 = Psto1;
			setDirty(true);
			if (!_isClone && _dataset != null)
			{
				_dataset.setDirty(StateMod_DataSet.COMP_PLANS, true);
			}
		}
	}

	/// <summary>
	/// Set the plan initial storage. </summary>
	/// <param name="Psto1"> plan initial storage. </param>
	public virtual void setPsto1(double? Psto1)
	{
		setPsto1(Psto1.Value);
	}

	/// <summary>
	/// Set the plan initial storage. </summary>
	/// <param name="Peff"> Plan initial storage. </param>
	public virtual void setPsto1(string Psto1)
	{
		if (string.ReferenceEquals(Psto1, null))
		{
			return;
		}
		setPsto1(StringUtil.atod(Psto1.Trim()));
	}

	/// <summary>
	/// Write plan information to output.  History header information 
	/// is also maintained by calling this routine. </summary>
	/// <param name="instrfile"> input file from which previous history should be taken </param>
	/// <param name="outstrfile"> output file to which to write </param>
	/// <param name="thePlans"> list of plans to write. </param>
	/// <param name="newComments"> addition comments which should be included in history </param>
	/// <exception cref="Exception"> if an error occurs. </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public static void writeStateModFile(String instrfile, String outstrfile, java.util.List<StateMod_Plan> thePlans, java.util.List<String> newComments) throws Exception
	public static void writeStateModFile(string instrfile, string outstrfile, IList<StateMod_Plan> thePlans, IList<string> newComments)
	{
		string routine = "StateMod_Plan.writeStateModFile";
		IList<string> commentIndicators = new List<string>(1);
		commentIndicators.Add("#");
		IList<string> ignoredCommentIndicators = new List<string>(1);
		ignoredCommentIndicators.Add("#>");
		PrintWriter @out = null;
		try
		{
			@out = IOUtil.processFileHeaders(IOUtil.getPathUsingWorkingDir(instrfile), IOUtil.getPathUsingWorkingDir(outstrfile), newComments, commentIndicators, ignoredCommentIndicators, 0);

			int i;
			string iline;
			string cmnt = "#>";
			// This format follows historical conventions
			string formatLine1 = "%-12.12s \"%-24.24s\" %-12.12s%8d%8d%8d%8d%8d%8d \"%-12.12s\" %8.8s";
			StateMod_Plan plan = null;
			IList<object> v = new List<object>(11); // Reuse for all output lines.

			@out.println(cmnt);
			@out.println(cmnt + "*************************************************");
			@out.println(cmnt + "  StateMod Plan Stations");
			@out.println(cmnt);
			@out.println(cmnt + "  Card 1 format:  Free, default used is: a12,2x,a24,2x,a12,1x,6i8,2x,a12,i8)");
			@out.println(cmnt + "                  The default format is consistent with internal data sizes.");
			@out.println(cmnt + "                  Strings containing spaces should be enclosed in quotes.");
			@out.println(cmnt + "                  Variable names are provided below consistent with documentation.");
			@out.println(cmnt);
			@out.println(cmnt + "  ID                Pid:  Plan ID");
			@out.println(cmnt + "  Name            Pname:  Plan name");
			@out.println(cmnt + "  River Node      iPsta:  River node for plan");
			@out.println(cmnt + "  On/Off            Pon:  Switch 0=off, 1=on");
			@out.println(cmnt + "  Type          iPlnTyp:  Plan type");
			@out.println(cmnt + "                          1=Terms and Conditions (T&C)");
			@out.println(cmnt + "                          2=Well Augmentation");
			@out.println(cmnt + "                          3=CU Reuse to a Reservoir");
			@out.println(cmnt + "                          4=CU Reuse to a Diversion");
			@out.println(cmnt + "                          5=CU Reuse to a Reservoir from Tmtn");
			@out.println(cmnt + "                          6=CU Reuse to a Diversion from Tmtn");
			@out.println(cmnt + "                          7=Tmtn Reuse");
			@out.println(cmnt + "                          8=Recharge Plan");
			@out.println(cmnt + "                          9=OOP Plan");
			@out.println(cmnt + "                          10=Special Well Augmentation Plan");
			@out.println(cmnt + "                          11=Accounting Plan");
			@out.println(cmnt + "                          12=Release Limit Plan");
			@out.println(cmnt + "  Eff              Peff:  Plan efficiency (%)");
			@out.println(cmnt + "                          0=do not use");
			@out.println(cmnt + "                          1=following line will have 12 monthly efficiencies.");
			@out.println(cmnt + "                          999=use source structure's efficiencies");
			@out.println(cmnt + "  RetType          iPrf:  Return flow typ.");
			@out.println(cmnt + "                          0=no return flows calculated");
			@out.println(cmnt + "                          1=T&C plan with return data in plan return flow file");
			@out.println(cmnt + "                          8=Recharge plan with return data in plan return flow file");
			@out.println(cmnt + "                          999=use source structure's return flow data");
			@out.println(cmnt + "  Fail           iPfail:  Failure switch");
			@out.println(cmnt + "                          0=Do not turn plan off if failure");
			@out.println(cmnt + "                          1=turn plan off if it fails");
			@out.println(cmnt + "  Storage         Psto1:  Initial storage (AF)");
			@out.println(cmnt + "  Source        PSource:  Source ID of structure where plan water becomes available");
			@out.println(cmnt + "  Account         iPAcc:  Source account of structure where plan water becomes available");
			@out.println(cmnt);
			@out.println(cmnt + " ID          Name                      RiverLoc    On/Off  iPtype  Peff    iPrf    " + "iPfail  Psto1     Psource       PAcct");
			@out.println(cmnt + "---------exxb----------------------exxb----------eb------eb------eb------eb------e" + "b------eb------exxb----------exxb------e");
			@out.println(cmnt + "EndHeader");

			int num = 0;
			if (thePlans != null)
			{
				num = thePlans.Count;
			}
			for (i = 0; i < num; i++)
			{
				plan = thePlans[i];
				if (plan == null)
				{
					continue;
				}

				// Comments before data.

				IList<string> commentsBeforeData = plan.getCommentsBeforeData();
				int numComments = commentsBeforeData.Count;
				// Print the comments in front of the operational right
				// The original comments were stripped of the leading # but otherwise are padded with whitespace
				// as per the original - when written they should exactly match the original
				for (int j = 0; j < numComments; j++)
				{
					@out.println("#" + commentsBeforeData[j]);
				}

				// line 1
				v.Clear();
				v.Add(plan.getID());
				v.Add(plan.getName());
				v.Add(plan.getCgoto());
				v.Add(new int?(plan.getSwitch()));
				v.Add(new int?(plan.getIPlnTyp()));
				v.Add(new int?(plan.getPeffFlag()));
				v.Add(new int?(plan.getIPrf()));
				v.Add(new int?(plan.getIPfail()));
				v.Add(new double?(plan.getPsto1()));
				v.Add(plan.getPsource());
				v.Add(plan.getIPAcc());
				iline = StringUtil.formatString(v, formatLine1);
				@out.println(iline);

				// Line 2

				if (plan.getPeffFlag() == 1)
				{
					for (int iEff = 0; iEff < 12; iEff++)
					{
						if (iEff > 0)
						{
							@out.print(" ");
						}
						@out.print(StringUtil.formatString(plan.getPeff(iEff),"%6.2f"));
					}
					@out.println("");
				}
			}
		}
		catch (Exception e)
		{
			Message.printWarning(3, routine, e);
			throw e;
		}
		finally
		{
			if (@out != null)
			{
				@out.flush();
				@out.close();
			}
		}
	}

	// TODO SAM 2006-08-22
	// Enable when plan stations are enabled in StateDMI
	/// <summary>
	/// Writes a Vector of StateMod_Plan objects to a list file.  A header is 
	/// printed to the top of the file, containing the commands used to generate the 
	/// file.  Any strings in the body of the file that contain the field delimiter will be wrapped in "...". </summary>
	/// <param name="filename"> the name of the file to which the data will be written. </param>
	/// <param name="delimiter"> the delimiter to use for separating field values. </param>
	/// <param name="update"> whether to update an existing file, retaining the current 
	/// header (true) or to create a new file with a new header. </param>
	/// <param name="data"> the Vector of objects to write. </param>
	/// <exception cref="Exception"> if an error occurs. </exception>
	/*
	public static void writeListFile(String filename, String delimiter,
	boolean update, Vector data) 
	throws Exception {
		int size = 0;
		if (data != null) {
			size = data.size();
		}
		
		Vector fields = new Vector();
		fields.add("ID");
		fields.add("Name");
		fields.add("RiverNodeID");
		fields.add("OnOff");
		fields.add("Capacity");
		fields.add("ReplaceResOption");
		fields.add("DailyID");
		fields.add("UserName");
		fields.add("DemandType");
		fields.add("EffAnnual");
		fields.add("IrrigatedAcres");
		fields.add("UseType");
		fields.add("DemandSource");
		fields.add("EffMonthly01");
		fields.add("EffMonthly02");
		fields.add("EffMonthly03");
		fields.add("EffMonthly04");
		fields.add("EffMonthly05");
		fields.add("EffMonthly06");
		fields.add("EffMonthly07");
		fields.add("EffMonthly08");
		fields.add("EffMonthly09");
		fields.add("EffMonthly10");
		fields.add("EffMonthly11");
		fields.add("EffMonthly12");
		int fieldCount = fields.size();
	
		String[] names = new String[fieldCount];
		String[] formats = new String[fieldCount]; 
		int comp = StateMod_DataSet.COMP_PLANS;
		String s = null;
		for (int i = 0; i < fieldCount; i++) {
			s = (String)fields.elementAt(i);
			names[i] = StateMod_Util.lookupPropValue(comp, "FieldName", s);
			formats[i] = StateMod_Util.lookupPropValue(comp, "Format", s);
		}
	
		String oldFile = null;	
		if (update) {
			oldFile = IOUtil.getPathUsingWorkingDir(filename);
		}
		
		int j = 0;
		int size2 = 0;
		PrintWriter out = null;
		String[] commentString = { "#" };
		String[] ignoreCommentString = { "#>" };
		String[] line = new String[fieldCount];
		String[] newComments = null;
		String id = null;
		StringBuffer buffer = new StringBuffer();
		StateMod_Diversion div = null;
		StateMod_ReturnFlow rf = null;
		Vector returnFlows = new Vector();
		Vector temp = null;
		
		try {	
			out = IOUtil.processFileHeaders(
				oldFile,
				IOUtil.getPathUsingWorkingDir(filename), 
				newComments, commentString, ignoreCommentString, 0);
	
			for (int i = 0; i < fieldCount; i++) {
				buffer.append("\"" + names[i] + "\"");
				if (i < (fieldCount - 1)) {
					buffer.append(delimiter);
				}
			}
	
			out.println(buffer.toString());
			
			for (int i = 0; i < size; i++) {
				div = (StateMod_Diversion)data.elementAt(i);
				
				line[0] = StringUtil.formatString(div.getID(), 
					formats[0]).trim();
				line[1] = StringUtil.formatString(div.getName(), 
					formats[1]).trim();
				line[2] = StringUtil.formatString(div.getCgoto(), 
					formats[2]).trim();
				line[3] = StringUtil.formatString(div.getSwitch(), 
					formats[3]).trim();
				line[4] = StringUtil.formatString(div.getDivcap(), 
					formats[4]).trim();
				line[5] = StringUtil.formatString(div.getIreptype(), 
					formats[5]).trim();
				line[6] = StringUtil.formatString(div.getCdividy(), 
					formats[6]).trim();
				line[7] = StringUtil.formatString(div.getUsername(), 
					formats[7]).trim();
				line[8] = StringUtil.formatString(div.getIdvcom(), 
					formats[8]).trim();
				line[9] = StringUtil.formatString(div.getArea(), 
					formats[9]).trim();
				line[10] = StringUtil.formatString(div.getIrturn(), 
					formats[10]).trim();
				line[11] = StringUtil.formatString(div.getDemsrc(), 
					formats[11]).trim();
				line[12] = StringUtil.formatString(div.getDivefc(), 
					formats[12]).trim();
				line[13] = StringUtil.formatString(div.getDiveff(0), 
					formats[13]).trim();
				line[14] = StringUtil.formatString(div.getDiveff(1), 
					formats[14]).trim();
				line[15] = StringUtil.formatString(div.getDiveff(2), 
					formats[15]).trim();
				line[16] = StringUtil.formatString(div.getDiveff(3), 
					formats[16]).trim();
				line[17] = StringUtil.formatString(div.getDiveff(4), 
					formats[17]).trim();
				line[18] = StringUtil.formatString(div.getDiveff(5), 
					formats[18]).trim();
				line[19] = StringUtil.formatString(div.getDiveff(6), 
					formats[19]).trim();
				line[20] = StringUtil.formatString(div.getDiveff(7), 
					formats[20]).trim();
				line[21] = StringUtil.formatString(div.getDiveff(8), 
					formats[21]).trim();
				line[22] = StringUtil.formatString(div.getDiveff(9), 
					formats[22]).trim();
				line[23] = StringUtil.formatString(div.getDiveff(10),
					formats[23]).trim();
				line[24] = StringUtil.formatString(div.getDiveff(11),
					formats[24]).trim();
	
				buffer = new StringBuffer();	
				for (j = 0; j < fieldCount; j++) {
					if (line[j].indexOf(delimiter) > -1) {
						line[j] = "\"" + line[j] + "\"";
					}
					buffer.append(line[j]);
					if (j < (fieldCount - 1)) {
						buffer.append(delimiter);
					}
				}
	
				out.println(buffer.toString());
	
				temp = div.getReturnFlows();
				size2 = temp.size();
				id = div.getID();
				for (j = 0; j < size2; j++) {
					rf = (StateMod_ReturnFlow)temp.elementAt(j);
					rf.setID(id);
					returnFlows.add(rf);
				}
			}
			out.flush();
			out.close();
			out = null;
		}
		catch (Exception e) {
			if (out != null) {
				out.flush();
				out.close();
			}
			out = null;
			throw e;
		}
	
		int lastIndex = filename.lastIndexOf(".");
		String front = filename.substring(0, lastIndex);
		String end = filename.substring((lastIndex + 1), filename.length());
		
		String returnFlowFilename = front + "_ReturnFlows." + end;
		StateMod_ReturnFlow.writeListFile(returnFlowFilename, delimiter,
			update, returnFlows,
			StateMod_DataSet.COMP_DIVERSION_STATION_DELAY_TABLES);
	
		String collectionFilename = front + "_Collections." + end;
		writeCollectionListFile(collectionFilename, delimiter,
			update, data);		
	}
		*/

	}

}